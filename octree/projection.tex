\subsection{Projection algorithm}
\paragraph{}
In the proposed method, the mesh is generated by \hl{the} method introduced in \cite{Liu2017} where intersections are calculated between the edge of the element and the triangular surface.
These triangular surfaces extracted from the STL files are an approximation of the exact geometry.
In order to retain the exact geometry, \hl{a} point projection algorithm is required to find the nearest point in parameter $(u, v)$ on the NURBS surface of the intersection point.
\hl{This is achieved by finding a few possible sub-surfaces generated in Sec.}~\ref{oct_sc:surface_division} \hl{and finding the projection points $\mathbf{P}^\prime$ of the test point $P$ on these surfaces.
The projection point $P_i^\prime$ with minimum $|P_i^\prime P|$ is adopted as the solution.
}


\paragraph{}
\hl{After all NURBS surfaces are divided into smaller ones, a filtering algorithm will be conducted for the test point $P$ in order to limited the candidate subsurfaces to only a few.
The convex hull property of the NURBS surface introduced in Sec.}~\ref{lr_sec:NURBS} \hl{indicates that all points on the surface must be contained within the convex hull constructed by its control points.
Considering the fact that the test point $P$ is on the triangular surface of the STL file and the STL file is an approximation of the exact geometry, it can be concluded that the point $P$ shall be also contained by the convex hull or be extremely close to it.
As a consequence, convex hulls will be constructed for all sub-surfaces and those who do not contain the point $P$ will be filtered.
If the point $P$ is not in any convex hull, distances between the point to them are calculated and 3 sub-surfaces whose convex hulls have the smallest distances to the point are selected as the candidates.}

\paragraph{}
\hl{After that, the projection points of the test point $P$ to each individual candidate sub-surface are calculated.}
Some $O(logN)$ algorithms were developed \citep{Edelsbrunner:1985:CED:4007.4011, Chin1983OptimalAF} while presumably large number of tests on polygons is imposed.
Furthermore, the accuracy is out of satisfactory for computer graphics and CAD communities.
As a consequence, a projection algorithm \citep{MA200379} using Newton-Raphson method is introduced to tackle this problem.

\paragraph{}
For a given point $P=(x,y,z)$, its projection on the surface $S(u, v)$ so that the distance $|P-S(u,v)|$ is minimum is targeted.
In order to find the projection, the vector $r$ is defined as
\begin{equation}
    \mathbf{r} (u, v) =
    \mathbf{S} (u, v) -
    \mathbf{P}
\end{equation}
%
and two scalars $f$ and $g$ are defined as
\begin{equation}
    \left\{
        \begin{array}{rl}
            f (u, v) =
            \mathbf{r}(u, v) \mathbf{\cdot} \mathbf{S}_u (u, v)
            = 0 & \\
            g (u, v) =
            \mathbf{r}(u, v) \mathbf{\cdot} \mathbf{S}_v (u, v)
            = 0 &
        \end{array}
    \right.
\label{oct_eq:projection_function}
\end{equation}
%
In order to solve Eq.~\ref{oct_eq:projection_function}, several notations are introduced
\begin{align*}
    \delta_i &=
        \begin{bmatrix}
            \Delta u \\
            \Delta v
        \end{bmatrix} = 
        \begin{bmatrix}
            u_{i+1} - u_i \\
            v_{i+1} - v_i
        \end{bmatrix} \\
    J_i &=
        \begin{bmatrix}
            f_u & f_v \\
            g_u & g_v
        \end{bmatrix} = 
        \begin{bmatrix}
            \boldmath
            |S_u|^2 + r \cdot S_{uu}        &       S_u \cdot S_v + r \cdot S_{uv} \\
            S_u \cdot S_v + r \cdot S_{uv}  &       |S_v|^2 + r \cdot S_{vv}
        \end{bmatrix} \\
    \kappa_i & = -
        \begin{bmatrix}
            f(u_i, v_i) \\
            g(u_i, v_i)
        \end{bmatrix}
\end{align*}
%
Where all values in matrix $j_i$ \hl{$J_i$} can be evaluated at $(u_i, v_i)$.
$2$ by $2$ matrix $\delta_i$ can be determined at step $i$ as
\begin{equation}
    J_i \delta_i = \kappa_i
\end{equation}
%
It can be derived by utilizing $\delta_i$ so that
\begin{subequations}
\begin{align}
    u_{i+1} & = u_i + \Delta u \\
    v_{i+1} & = v_i + \Delta v
\end{align}
\label{oct_eq:projection_iteration}
\end{subequations}
%
The iteration can be concluded as
\paragraph{1}
Is the point coincide with $S(u_i, v_i)$ ?
\begin{equation*}
    |\mathbf{S} (u_i, v_i) - \mathbf{P}| \leq \epsilon_1
\end{equation*}
%
where $\epsilon_1$ stands for the tolerance for distance in Euclidean space.
\paragraph{2}
Is the cosine zero ?
\begin{align*}
    \frac{
        |\mathbf{S}_u (u_i, v_i) \cdot
        \left(
            \mathbf{S}(u_i, v_i) - \mathbf{P}
        \right)|
    }{
        |\mathbf{S}_u (u_i, v_i)|
        |\mathbf{S}(u_i, v_i) - \mathbf{P}|
    } & \leq \epsilon_2 \\
    \frac{
        |\mathbf{S}_v (u_i, v_i) \cdot
        \left(
            \mathbf{S}(u_i, v_i) - \mathbf{P}
        \right)|
    }{
        |\mathbf{S}_v (u_i, v_i)|
        |\mathbf{S}(u_i, v_i) - \mathbf{P}|
    } & \leq \epsilon_2
\end{align*}
%
where $\epsilon_2$ stands for the tolerance for cosine.
If either of these conditions are met, the iteration is terminated.
Otherwise Eq.~\ref{oct_eq:projection_iteration} is performed to find the parameters $u_{i+1}$ and $v_{i+1}$ for next iteration.
\paragraph{3}
Make sure $u$ and $v$ are within there domains
\begin{align*}
    u_{i+1} & \in [a,b] \\
    v_{i+1} & \in [c,d]
\end{align*}
%
where $a$, $b$, $c$ and $d$ are the lower and upper bounds for the knot vectors of surface $S$.
If the surface is open in $u$ direction
\begin{equation}
    \left\{
        \begin{array}{rl}
            u_{i+1} = a & u_{i+1} < a \\
            u_{i+1} = b & u_{i+1} > b
        \end{array}
    \right.
\end{equation}
%
If the surface is open in $v$ direction
\begin{equation}
    \left\{
        \begin{array}{rl}
            v_{i+1} = c & v_{i+1} < c \\
            v_{i+1} = d & v_{i+1} > d
        \end{array}
    \right.
\end{equation}
%
If the surface is closed in $u$ direction
\begin{equation}
    \left\{
        \begin{array}{rl}
            u_{i+1} = b - ( a - u_{i+1} ) & u_{i+1} < a \\
            u_{i+1} = a + ( u_{i+1} - b ) & u_{i+1} > b
        \end{array}
    \right.
\end{equation}
%
If the surface is closed in $v$ direction
\begin{equation}
    \left\{
        \begin{array}{rl}
            v_{i+1} = d - ( c - v_{i+1} ) & v_{i+1} < c \\
            v_{i+1} = c + ( v_{i+1} - d ) & v_{i+1} > d
        \end{array}
    \right.
\end{equation}
%
\paragraph{4}
The difference between the new parameters $u_{i+1}$ and $v_{i+1}$ and the old ones $u_i$ and $v_i$ is insignificant ?
\begin{equation*}
    |u(i+1) - u_i| \mathbf{S}_u (u_i, v_i) +
    (v_{i+1} - v_i) \mathbf{S}_v (u_i, v_i) |
    \leq \epsilon_1
\end{equation*}
The iteration will be terminated if this condition is met.